<!-- Autogenerated by mlir-tblgen; don't manually edit -->
# Operation definition
## linalg.buffer_alloc (linalg::BufferAllocOp)
buffer allocation operation

### Description:

The "buffer_alloc" op creates a 1-D linalg.buffer of the specified type,
upon which a base view can be laid out to give it indexing semantics.
"buffer_alloc" takes a single argument, the size of the buffer to allocate
(in number of elements).
An optional alignment attribute may be specified in which case the actual
underlying allocation size may be increased. The base pointer is guaranteed
to be a multiple of `alignment`. Such an alignment must be a positive power
of 2.

Examples:

    %0 = linalg.buffer_alloc(%arg0) : !linalg.buffer<?xf32>

    %1 = linalg.buffer_alloc(%arg0) { alignment = 16 } :
      !linalg.buffer<?xf32>

The size argument may be omitted if it is statically known, in which case it
must be reflected in the type.

Example:

    %0 = linalg.buffer_alloc() : !linalg.buffer<4xf32>

### Operands:
1. `size`: index

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `alignment` | `IntegerAttr` | 64-bit integer attribute attribute |

### Results:
1. &laquo;unnamed&raquo;: buffer

## linalg.buffer_dealloc (linalg::BufferDeallocOp)
buffer allocation operation

### Description:

The "buffer_dealloc" op frees a 1-D linalg.buffer of the specified type.

Example:

    linalg.buffer_dealloc %0 : !linalg.buffer<f32>

### Operands:
1. `buffer`: buffer

### Attributes:

### Results:

## linalg.buffer_size (linalg::BufferSizeOp)
buffer size operation

### Description:

The "linalg.buffer_size" operation takes a linalg.buffer and returns an
"index".

Example:

   %0 = linalg.buffer_size %arg0 : !linalg.buffer<f32>

### Operands:
1. `buffer`: buffer

### Attributes:

### Results:
1. &laquo;unnamed&raquo;: index

## linalg.dim (linalg::DimOp)
dimension index operation

### Description:

The "linalg.dim" operation takes a linalg.view and returns an
"index". It requires a single integer attribute named "index". It
 returns the size of the specified dimension.

 Example:

   %1 = linalg.dim %0, 2 : view<?x?x?xf32>

### Operands:
1. `view`: view

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `index` | `IntegerAttr` | arbitrary integer attribute attribute |

### Results:
1. &laquo;unnamed&raquo;: index

## linalg.load (linalg::LoadOp)
Read an elemental value from a view at a certain index

### Description:

The `linalg.load` op reads an elemental value from a view at a certain
index. This is the counterpart of other load ops but operating on ViewType.

Example:

   %0 = linalg.load %V[%c0] : !linalg.view<?xf32>

### Operands:
1. `view`: view
1. `indices`: index

### Attributes:

### Results:
1. `value`: any type

## linalg.range (linalg::RangeOp)
Create a range type value, used to create views

### Description:

The `linalg.range` op creates a linalg.range from 3 values of type `index`
that represent the min, max and step values of the range.

Example:

  %3 = linalg.range %0:%1:%2 : !linalg.range

### Operands:
1. `min`: index
1. `max`: index
1. `step`: index

### Attributes:

### Results:
1. &laquo;unnamed&raquo;: range

## linalg.slice (linalg::SliceOp)
Produce a linalg.view which is a subview of a base view.

### Description:

The "linalg.slice" op produces a linalg.view which is a subview of a given
base view. This allows defining a subregion within the underlying buffer to
operate on only a subset of the buffer.

A "linalg.slice" op takes a view and a variadic number of indexings and
produces a linalg.view of the same elemental type. An indexing is either:
  1. a linalg.range, in which case it does not reduce the rank of the parent
     view.
  2. an index, in which case it reduces the rank of the parent view by one.

If an indexing extends past the size of the view, the slice operation
automatically truncates it to be within the bounds.

Examples:

  1. rank-preserving slice:

    %4 = linalg.slice %0[%1, %2] : !linalg.view<?x?xf32>, !linalg.range,
           !linalg.range, !linalg.view<?x?xf32>

  2. rank-reducing slice (from 2-D to 1-D):

    %4 = linalg.slice %0[%1, %2] : !linalg.view<?x?xf32>, index,
           !linalg.range, !linalg.view<?xf32>

  3. rank-reducing slice (from 2-D to 0-D):

    %4 = linalg.slice %0[%1, %2] : !linalg.view<?x?xf32>, index, index,
           !linalg.view<f32>

### Operands:
1. `view`: view
1. `indexings`: range or index

### Attributes:

### Results:
1. &laquo;unnamed&raquo;: view

## linalg.store (linalg::StoreOp)
Write an elemental value in a view at a certain index

### Description:

The `linalg.store` op writes an elemental value in a view at a certain
index. This is the counterpart of other store ops but operating on ViewType.

Example:

  linalg.store %f, %V[%c0] : !linalg.view<?xf32>

### Operands:
1. `value`: any type
1. `view`: view
1. `indices`: index

### Attributes:

### Results:

## linalg.subview (linalg::SubViewOp)
subview operation

### Description:

The "linalg.subview" op produces a linalg.view which is a subview of a given
base view. This allows defining a subregion within the underlying buffer.

The "linalg.subview" operation takes a base view, a list of indices and
returns a new linalg.view of the same type that is contained within the
view. This operation is equivalent to a non-rank-reducing slice operation.
The main difference is the operands are all of type `index` and no
intermediate linalg.range operations are required. A "linalg.subview" is
thus a specialized linalg.slice with a higher level of abstraction.

Similary to linalg.slice, if a range extends past the size of the base view,
the slice operation automatically truncates it to be within the bounds of
the view.

Example:

  %1 = linalg.subview %0[%1, %2, %3, %4, %5, %6] : view<?x?xf32>


### Operands:
1. `view`: view
1. `ranges`: index

### Attributes:

### Results:
1. &laquo;unnamed&raquo;: view

## linalg.transpose (linalg::TransposeOp)
transpose operation produces a new view (metadata-only)

### Description:

The "linalg.transpose" op produces a linalg.view whose sizes and strides are
a permutation of the original. This is a pure metadata transformation.

Example:

   %1 = linalg.transpose %0 (i, j) -> (j, i) : !linalg.view<?x?xf32>

### Operands:
1. `view`: view

### Attributes:
| Attribute | MLIR Type | Description |
| :-------: | :-------: | ----------- |
| `permutation` | `AffineMapAttr` | AffineMap attribute attribute |

### Results:
1. &laquo;unnamed&raquo;: view

## linalg.view (linalg::ViewOp)
view operation

### Description:

The "linalg.view" op produces a linalg.view which is a multi-dimensional
range abstraction on top of an underlying linalg.buffer. This gives an
indexing structure to an otherwise non-indexable linalg.buffer.

A "linalg.view" takes a buffer and a variadic number of ranges and produces
a `view` of rank the number of ranges. The elemental type may not match the
buffer element type:

Example:

   %1 = linalg.buffer_alloc %0 : !linalg.buffer<f32>
   %2 = linalg.range %arg2:%arg3:%arg4 : !linalg.range
   %3 = linalg.view %1[%2, %2] : !linalg.view<?x?xvector<4xf32>>

### Operands:
1. `buffer`: buffer
1. `ranges`: range

### Attributes:

### Results:
1. &laquo;unnamed&raquo;: view

## linalg.yield (linalg::YieldOp)
Linalg yield operation

### Description:

"linalg.yield" is a special terminator operation for blocks inside regions
in linalg ops. It returns values to the immediately enclosing linalg op.

Example:

   linalg.yield %f0, %f1 : f32, f32

### Operands:
1. `values`: any type

### Attributes:

### Results:

